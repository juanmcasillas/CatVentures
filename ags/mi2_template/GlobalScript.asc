// Automatically converted interaction variables
int IntVar_Global_1 = 0;
export IntVar_Global_1;
///////////////////////////////////////////////////////////////////////////
/////// SCUMM TEMPLATE EMULATING MI2 INTERFACE BY PROSKRITO v2.0c /////////
///////////////////////////////////////////////////////////////////////////
/////** PLEASE READ THE 'README' FILE THAT COMES WITH THE TEMPLATE **//////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
// main global script file


//SOME TEMPLATE DEFINITIONS:

//-----------------------------------------------------------------------------------------------
#define MAX_MODES 			11//	put here how many cursor modes you have (= last
//						number in mode '#defines' in the Script Header+1).
//						Putting a lower number will cause strange errors.
//-----------------------------------------------------------------------------------------------
#define MAX_SAVEGAMES 			99//    Max number of savegames.
//-----------------------------------------------------------------------------------------------
#define EXTENSION_IDENTIFIER 		">"//	Character(s) extensions start with. 
#define VARIABLE_DEF_ACTION_EXTENSION	'v'//	Extension for variable default action things.
#define NO_DEF_ACTION_EXTENSION		'n'//	Extension for no default action things.
#define EXITS_EXTENSION			'e'//	Extension for exit type things.
//-----------------------------------------------------------------------------------------------
#define ALWAYS_GO_TO_HOTSPOTS 		1//	Read the template documentation for this.
//-----------------------------------------------------------------------------------------------
#define DEFAULT_FONT_HEIGHT 		8//	Used in SaveGame GUI script
//-----------------------------------------------------------------------------------------------
#define GUI_MAPS_WIDTH 			100//	Used for setting up the GUI label in map rooms .
#define GUI_MAPS_LABEL_FONT 		1//
//-----------------------------------------------------------------------------------------------
#define INV_UP_ARROW_ON_SPRITE 		11//	Used for setting the correct arrows so that the 
#define INV_UP_ARROW_OFF_SPRITE 	34//	player can see if the inventory is scrollable.
#define INV_DOWN_ARROW_ON_SPRITE 	10//
#define INV_DOWN_ARROW_OFF_SPRITE 	34//
//-----------------------------------------------------------------------------------------------
#define ACTION_LABEL_COLOR_NORMAL	 5//	Used in highlighting the action bar.
#define ACTION_LABEL_COLOR_HIGHLIGHTED 	13//
//-----------------------------------------------------------------------------------------------
#define BLANK_CURSOR_SPRITE_NUMBER 	34//	Used for changing the cursor back to 'wait' 
//						cursor after 'semi-blocking' functions finish. 
//-----------------------------------------------------------------------------------------------
#define FIRST_INV_SLOT_COORDS 	    180,160//	Any point inside the top left inventory slot.
//-----------------------------------------------------------------------------------------------
#define CONFIRM_GUIS_CHARACTER_YES	'Y'//	Keys for 'Yes' and 'No' in 'exit game' and 
#define CONFIRM_GUIS_CHARACTER_NO	'N'//	'restart game' GUI requests. (Always uppercase)
//-----------------------------------------------------------------------------------------------
#define SPECIAL_INV_MODE		1//	1 = LOOK mode (as defined in script header).
//						It is the mode that will trigger a left click
//						in the inventory if mode is WALK or PICKUP.
//-----------------------------------------------------------------------------------------------

//	Global script template variables
//-----------------------------------------------------

struct cursormode {
   int AGSmode;char name[200];char preposition[200];char extension;int onlyinv;
   int caninteractwithinv;int button;int normalbutton;int highlightedbutton;
};

cursormode Tmode[MAX_MODES];

string 
GSlocname;

int 
GStopsaveitem=0,
GSloctype,
GSlocid,
GSusedmode,
GSmode,
GSdefaultmode;
//-----------------------------------------------------

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// TEMPLATE FUNCTIONS ////////////////////////////////////////// TEMPLATE FUNCTIONS //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//	Modes setup functions
//-----------------------------------------------------
function DefineButton(int mode, int button, int normalbuttonpic, int overbuttonpic){
  //Define the buttons for a template mode. Call it in game_start for each mode to
  //set up them all.
  Tmode[mode].button=button;
  Tmode[mode].highlightedbutton=overbuttonpic;
  Tmode[mode].normalbutton=normalbuttonpic;
}

function DefineMode(int mode, const string name, int AGSmode, char extension){
  //Define non-inventory template modes. Call it in game_start for each mode to
  //set up them all.
  StrCopy(Tmode[mode].name, name);
  Tmode[mode].AGSmode = AGSmode;
  if (extension!=0) Tmode[mode].extension = extension;
}

function DefineInvMode(int mode, const string name, const string preposition, int onlyinv, int caninteractwithinv, char extension){
  //Define inventory template modes. Call it in game_start for each mode to
  //set up them all.
  DefineMode(mode, name, 2, extension);
  StrCopy(Tmode[mode].preposition, preposition);
  Tmode[mode].onlyinv = onlyinv;
  Tmode[mode].caninteractwithinv = caninteractwithinv;
}

function ResetModes(){
  int counter=0;
  while (counter<MAX_MODES){
    Tmode[counter].AGSmode=-1;
    StrCopy(Tmode[counter].name,"");
    StrCopy(Tmode[counter].preposition,"");
    Tmode[counter].extension=-1;
    Tmode[counter].onlyinv=-1;
    Tmode[counter].caninteractwithinv=-1;
    Tmode[counter].button=-1;
    Tmode[counter].normalbutton=-1;
    Tmode[counter].highlightedbutton=-1;
    counter++;
  }
}
//-----------------------------------------------------

//	Setting modes functions
//-----------------------------------------------------

function SetMode(int mode){
  //Set the template mode. Pass DEFAULT as mode to set the default mode (usually WALK)
  if (mode==DEFAULT) mode=GSdefaultmode;
  GSmode=mode;
  if (Tmode[mode].AGSmode==4) Tmode[mode].AGSmode=2;
}

function SetDefaultMode(int mode){
  //sets the default mode in game,the one that will the game return to when an interaction
  //is over.  usually "walk to".
GSdefaultmode=mode;
SetMode(mode);
}

//-----------------------------------------------------

//	Checking modes functions
//-----------------------------------------------------

function UsedMode(int mode){ 
// It´s used for checking if the template mode passed as parameter was the one used in 
// the last interaction. 
  return (mode==GSusedmode); 
}

function UsedInvMode(int mode, int item){
// It´s used for checking if the template inventory mode passed as parameter 'mode'
// was used with the inventory item passed as parameter 'item'. 
  return (UsedMode(mode) && Tmode[mode].AGSmode==4 && character[GetPlayerCharacter()].activeinv==item);
}

function GetUsedMode(){
  //returns the template used mode.
  return GSusedmode;
}

function Mode(int mode){ 
  // Checks if the mode passed as parameter is the current template mode.
return (GSmode==mode);
}

function GetAGSMode(int mode){
  // Returns the AGS cursor mode of the template mode passed as parameter
  return Tmode[mode].AGSmode;
}

function GetMode(){
  // Returns the current template mode.
  return GSmode;
}
//-----------------------------------------------------

//	Extensions functions
//-----------------------------------------------------

function ExtensionEx(int index, string name){
  //returns the extension in the position 'index' of the string 'name'.
  //returns 0 if the name has no extension, and -1 if you passed an empty string.
  if (StrLen(name)==0) return -1;//if you passed an empty string
  int pos;
  pos=StrContains(name,EXTENSION_IDENTIFIER);
  if (pos==-1) return 0;
  else return StrGetCharAt(name,pos+StrLen(EXTENSION_IDENTIFIER)+index-1);
}

function Extension(string location){
  // Check the (first) extension (>*) of a string
  return ExtensionEx(1,location);
}

function RemoveExtension(string name){
  //removes the extension of a string  
  int pos=StrContains(name,EXTENSION_IDENTIFIER);
  if (Extension(name)>0) StrSetCharAt(name,pos,0);
}
//-----------------------------------------------------

//	Miscellaneous functions
//-----------------------------------------------------

function GlobalCondition(int parameter){
// here are some conditions that are used many times in the script
  if (parameter==1){//if the mouse is in the inventory and modes Walk or pickup are selected
    return ( GetInvAt(mouse.x,mouse.y)>=0 && (GetAGSMode(GetMode())==9 || GetAGSMode(GetMode())==5) );
  }
  else if (parameter==2){//if the mode is useinv and the mouse is over the active inv (like "use knife on knife")
    return (character[GetPlayerCharacter()].activeinv==GetInvAt(mouse.x,mouse.y) && GetAGSMode(GetMode())==4);
  }
  else if (parameter==3){//if the mode is talk, or "Give", and the mouse isnt over a character
    return (   (GetAGSMode(GetMode())==MODE_TALK || (Mode(GIVE) && GetAGSMode(GetMode())==4) ) && GetLocationType(mouse.x,mouse.y)!=2  );
  }
  else if (parameter==4){//if its a 'only inventory' mode (like GIVE), and the mouse isnt over a inv.item
    return (GetAGSMode(GetMode())==MODE_USE && Tmode[GSmode].onlyinv==1 && GetInvAt(mouse.x,mouse.y)<0);
  }
}

function GetLucasSavegameListBox(int guival,int objectval){ 
  // Fills a listbox with the savegames in the lucas format: '1. description'
  string buffer, sgdesc;
  int counter=0;
  ListBoxClear(guival,objectval);
  while (counter<MAX_SAVEGAMES) {
    StrFormat(buffer,"%d. ",counter+1);
    if (GetSaveSlotDescription(counter+100,sgdesc)!=1) StrCopy(sgdesc,"");
    StrCat(buffer,sgdesc);
    ListBoxAdd(guival,objectval,buffer);
    counter++;    
  }
  ListBoxSetTopItem(guival,objectval,GStopsaveitem);
  ListBoxSetSelected(guival,objectval,-1);
}

function Translation(const string language){
  // checks if the translation passed as parameter is being used. To check if no translation is being used, pass "none" or "default" as parameter.
  string currentlang;
  GetTranslationName(currentlang);
 if ((IsTranslationAvailable()==1 && StrCaseComp(currentlang, language)==0) || 
     (IsTranslationAvailable()==0 && (StrCaseComp("none", language)==0 || StrCaseComp("default", language)==0)))
      return 1;
 else return 0;
}
//-----------------------------------------------------

//	Action bar functions
//-----------------------------------------------------

function HighlightActionBar(){
  //highlights the action bar with the color defined at the top of the global script
  SetLabelColor(ACTION,0,ACTION_LABEL_COLOR_HIGHLIGHTED);
  SetTimer(20,5);
}

function UpdateActionBar(int roomx, int roomy){
// Set the text in the action bar depending on the current template mode and the thing under
// ROOM coordinates passed as parameters.
  string buffer;
  string madetext;
  int mode;
  mode=GSmode;
  if (GlobalCondition(1)==1) mode=SPECIAL_INV_MODE;
  StrCopy(madetext,Tmode[mode].name);
  StrCat(madetext," ");
  if (Tmode[GSmode].AGSmode == 4){
    GetInvName (character[GetPlayerCharacter()].activeinv, buffer);
    RemoveExtension(buffer);
    StrCat(madetext,buffer);
    StrCat(madetext," ");
    StrCat(madetext,Tmode[mode].preposition);
    StrCat(madetext," ");
  }
  if (GlobalCondition(2)==0 && GlobalCondition(3)==0 && GlobalCondition(4)==0){
  GetLocationName(roomx-GetViewportX(),roomy-GetViewportY(),buffer);
  RemoveExtension(buffer);
  StrCat(madetext,buffer); 
  }
  SetLabelText (ACTION, 0, madetext);
  if (IsTimerExpired(20)) SetLabelColor(ACTION, 0, ACTION_LABEL_COLOR_NORMAL);
}
//-----------------------------------------------------

//	Default action functions
//-----------------------------------------------------

function VariableDefaultAction(){
  //put here wich extension will show the things with variable extension ( >v )
  int room=character[GetPlayerCharacter()].room;
  int hotspotval=GetHotspotAt(mouse.x,mouse.y);
  if (room==1 && hotspotval==2){// if hotspot 2 of room 1
    if (GetGlobalInt(1)==0){ //if its closed
      return OPEN; //set 'OPEN' as default action
    }
    else{ //if its open 
      return CLOSE; //set 'CLOSE' as default action
    }
  }
} 

function GetDefaultAction(int x, int y){
  //returns the default action of the thing at the x,y SCREEN coordinates you pass to the function.
  int ext;
  string name;
  int type=GetLocationType(x,y);
  GetLocationName(x,y,name);
  ext=Extension(name);
  if (ext==-1) return 0; // if it has no name
  else if (GlobalCondition(2) || GlobalCondition(3) || GlobalCondition(4)) return 0;
  else if (ext==NO_DEF_ACTION_EXTENSION){// if the default action is none
    return 0;
  }
  else if (ext==VARIABLE_DEF_ACTION_EXTENSION){// if the default action deppends on some events
    return VariableDefaultAction();
  }
  int counter=0;
  while (counter<MAX_MODES){ // get the mode from its extension
    if (ext==Tmode[counter].extension) return counter;
    else counter++;
  }
////Setting default modes for things that have no extension (or unknown):
    if (type==2) //if it is a character
      return TALK; //set default action TALK
    else if (  ( type==0 && GetInvAt(mouse.x,mouse.y)>=0 ) || type!=0  )// if its a inv item,a hotspot or an object
      return LOOK; //set default action LOOK
    else 
      return 0; //set default action "none"
////////////////////////////////////////////////////////////////////
}

function HighlightButton(int mode){
  //highlights the appropiate button for the mode passed as parameter
int counter=0;
  while (counter<MAX_MODES){
    if (Tmode[counter].button!=-1){
      if (mode==counter){
        SetButtonPic(MAINGUI, Tmode[counter].button, 1, Tmode[counter].highlightedbutton);
      }
      else  SetButtonPic(MAINGUI, Tmode[counter].button, 1, Tmode[counter].normalbutton);
    }    
   counter++;
  }
}
//-----------------------------------------------------

//	Proccess Actions functions
//-----------------------------------------------------

function ProcessAction(int mode, int roomx, int roomy){
  //Proccess the action in the specified mode (template mode, not AGS cursor mode), at ROOM coords roomx, roomy.
  GSusedmode=mode;
  int AGSmode=Tmode[mode].AGSmode;
  UpdateActionBar(roomx,roomy); 
  if (GlobalCondition(3)==0 && GlobalCondition(4)==0){
    HighlightActionBar();
    if (AGSmode==9 && GetLocationType(roomx-GetViewportX(),roomy-GetViewportY())==0 && GetGUIAt(roomx-GetViewportX(),roomy-GetViewportY())<0)
      ProcessClick(roomx-GetViewportX(),roomy-GetViewportY(),MODE_WALK);
    else ProcessClick(roomx-GetViewportX(),roomy-GetViewportY(), AGSmode);
  }
  SetMode(DEFAULT);
}  

function ProcessInventoryAction(int mode, int invitem){
  //Proccess the action in the specified mode (template mode, not AGS cursor mode) with the inventory
  //item passed as parameter 'invitem'.
  GSusedmode=mode;
  int AGSmode=Tmode[mode].AGSmode;
    if(GlobalCondition(2)==0 && GlobalCondition(3)==0){
      if (AGSmode==2 && Tmode[mode].caninteractwithinv!=-1 && (Tmode[mode].caninteractwithinv==0 || IsInventoryInteractionAvailable(invitem,MODE_USE)==0) ){
        SetActiveInventory(invitem);
        Tmode[mode].AGSmode=4; 
        return;
      }
      else{
        UpdateActionBar(mouse.x+GetViewportX(), mouse.y+GetViewportY());
        HighlightActionBar();
        RunInventoryInteraction(invitem, AGSmode);
      }
    }
  SetMode(DEFAULT);
}
//-----------------------------------------------------

//	Move Player Functions
//-----------------------------------------------------
function MovePlayerEx(int x, int y, int direct){
  //Move the player character to x,y coords, waiting until he/she gets there, but allowing to cancel the action
  //by pressing a mouse button.
  #define DELAY 2 //delay of the cursor animation.
  int numframes=GetGameParameter(GP_NUMFRAMES,CURSOR,0,0)-1;
  int counter=0;
  if (direct==0) MoveCharacter(GetPlayerCharacter(),x,y);
  else MoveCharacterDirect(GetPlayerCharacter(),x,y);
  while (character[GetPlayerCharacter()].walking && ((IsButtonDown(LEFT)==1) || (IsButtonDown(RIGHT)==1))) {
    if (counter>numframes*DELAY) counter=0;
    ChangeCursorGraphic(7,GetGameParameter(GP_FRAMEIMAGE,CURSOR,0,counter/DELAY)); 
    counter++;
    Wait(1);    
    RefreshMouse();
  }
  // abort moving on new mouse down
  while (character[GetPlayerCharacter()].walking){
    if (IsButtonDown(LEFT)==1 && (GetGUIAt(mouse.x,mouse.y)<0 || GetInvAt(mouse.x,mouse.y)>=0)) {
      SetMode(DEFAULT);///????
      StopMoving(GetPlayerCharacter());
      ChangeCursorGraphic(7,BLANK_CURSOR_SPRITE_NUMBER);
      return 0;
    }
    else if (IsButtonDown(RIGHT)==1 && (GetGUIAt(mouse.x,mouse.y)<0 || GetInvAt(mouse.x,mouse.y)>=0)) {
      StopMoving(GetPlayerCharacter());
      ChangeCursorGraphic(7,BLANK_CURSOR_SPRITE_NUMBER);
      return 0;
    }
    else {
    if (counter>numframes*DELAY) counter=0;
      ChangeCursorGraphic(7,GetGameParameter(GP_FRAMEIMAGE,CURSOR,0,counter/DELAY)); 
      counter++;
      Wait(1);
      RefreshMouse();
      HighlightButton(GetDefaultAction(mouse.x,mouse.y));
    } 
  }
  ChangeCursorGraphic(7,BLANK_CURSOR_SPRITE_NUMBER);
  return 1;
}

function MovePlayer(int x, int y){
  //Move the player character to x,y coords, waiting until he/she gets there, but allowing to cancel the action
  //by pressing a mouse button.
return MovePlayerEx(x,y,0);
}

function Abs(int value){
  //used by GoTo functions
  if (value<0) return -value;
  else return value;
}

function Offset(int point1, int point2){
  //used by GoTo functions
  return Abs(point1-point2);
}

function GoToCharacterEx(int charidwhogoes, int charidtogo, int direction, int xoffset, int yoffset, int NPCfacesplayer, int blocking){
  //Goes to a character staying at the side defined by 'direction': 1 up, 2 right, 3 down, 4 left
  //and it stays at xoffset or yofsset from the character. NPCfacesplayer self-explained. ;)
  // blocking: 0=non-blocking; 1=blocking; 2=semi-blocking.
  // returns 1 if player arrived.
  int playerchar,charidx,charidy,playerx,playery;
  if (charidwhogoes!=GetPlayerCharacter() && blocking==2) blocking=0;//npcs cant perform semi-blocking actions
  playerchar=charidwhogoes;
  charidx=character[charidtogo].x;
  charidy=character[charidtogo].y;
  playerx=character[playerchar].x;
  playery=character[playerchar].y;
      int arrived = 1;
      if ((Offset (playerx, charidx) > xoffset) || (Offset (playery, charidy) > yoffset)){
        if (direction==0){ // shortest way.
          if (Offset(charidx,playerx)>=Offset(charidy,playery)){ // left or right
            if (playerx>=charidx) direction=2; //right
            else direction=4; //left
          }
          else{
            if (playery>=charidy) direction=3; //down
            else direction=1;
          }
        }
        // calculate target position
        if (direction==1) charidy-=yoffset;
        else if (direction==2) charidx+=xoffset;
        else if (direction==3) charidy+=yoffset;
        else if (direction==4) charidx-=xoffset;
        // move character
        if (blocking==0){
          MoveCharacter(playerchar,charidx,charidy);
          arrived = 0;
        }
        else if (blocking==1){
          MoveCharacterBlocking(playerchar,charidx,charidy,0);
          arrived = 1;
        }
        else if (blocking==2) arrived = MovePlayer(charidx,charidy);
      }
      if (arrived > 0){
        // characters only face each other after the moving character arrived at the target point
        if (NPCfacesplayer==1)  FaceCharacter(charidtogo, playerchar);
        FaceCharacter(playerchar, charidtogo);
      }
      return arrived;
}

function GoToCharacter(int charid, int direction, int NPCfacesplayer, int blocking){
  //same as above but with default x and y offset.
  int defaultxoffset, defaultyoffset;
  defaultxoffset=25;
  defaultyoffset=15;
  GoToCharacterEx(GetPlayerCharacter(),charid,direction,defaultxoffset,defaultyoffset,NPCfacesplayer,blocking);
}

function GoTo(int blocking){
  // Goes to whatever the player clicked on.
  // blocking: 0=non-blocking; 1=blocking; 2=semi-blocking
  int xtogo,ytogo;
  int locationtype=GSloctype;//GetLocationType(mouse.x,mouse.y);
  int playerchar=GetPlayerCharacter();
  int hotspotval=GSlocid;//GetHotspotAt(mouse.x,mouse.y);
  int arrived = 0;
  if (locationtype==2) arrived = GoToCharacter(GSlocid/*GetCharacterAt(mouse.x,mouse.y)*/,0,1,blocking);
  else{
     if (locationtype==1 && hotspotval>0 && GetHotspotPointX(hotspotval)!=-1) {
       xtogo=GetHotspotPointX(hotspotval);
       ytogo=GetHotspotPointY(hotspotval);
       }
     else if (locationtype==3) {
       int objectval=GSlocid;//GetObjectAt(mouse.x,mouse.y);
       xtogo=GetObjectX(objectval);
       ytogo=GetObjectY(objectval);
     }
     else {
       xtogo=mouse.x+GetViewportX();
       ytogo=mouse.y+GetViewportY();
       }
     if (blocking==0) MoveCharacter(playerchar,xtogo,ytogo);
     else if (blocking==1){
       MoveCharacterBlocking(playerchar,xtogo,ytogo,0);
       arrived = 1;
     }
     else if (blocking==2) arrived = MovePlayer(xtogo,ytogo);
    }
  return arrived;
}

function Go(){
 // Go to whatever the player clicked on. You can cancel the action, and returns 1 if the player has arrived to it.
  return GoTo(2); 
}
//-----------------------------------------------------

function WalkOffScreen(){
 //handles the action of hotspots with exit extension ('>e' by default).
 //double click in such hotspots/objects... will make the player skip
 //walking to it. Look the documentation for more information on exits.
  if (IsTimerExpired(19)==1){ 
    SetTimer(19,GetGameSpeed()/3);
    if (Go()){
      int x=character[GetPlayerCharacter()].x,y=character[GetPlayerCharacter()].y;
      int offset=30;
      int dir=ExtensionEx(2,GSlocname);
      if      (dir=='u') y-=offset;
      else if (dir=='d') y+=offset;
      else if (dir=='l') x-=offset;
      else if (dir=='r') x+=offset;
      if (MovePlayerEx(x,y,1)==1)
        RunHotspotInteraction(GSlocid,9);
    }
  }
  else RunHotspotInteraction(GSlocid,9);
}

//	Map rooms functions
//-----------------------------------------------------

function StartMapRoomEx(int labelcolour, int showplayersname){
  //call this function from the "player enters screen before f." interaction in the first
  //of the set of rooms that have the special maps gui. It lets you specify the label
  //colour and if the name of the player should be shown when the mouse is over it.
    GUIOff(MAINGUI);
    GUIOff(ACTION);
    game.auto_use_walkto_points=1;    
    SetMode(USE);
    if(labelcolour>=0) SetLabelColor(MAPS,0,labelcolour);
    SetCharacterClickable(GetPlayerCharacter(),showplayersname);
    GUIOn(MAPS);
}

function StartMapRoom(){
  //Same as StartMapRoomEx, but showing the players name, and with the label colour it
  //had the last time.
  StartMapRoomEx(-1,1);
}

function EndMapRoom(){
  //call this function from the "player leaves screen"  interaction in the last 
  //of the set of rooms that have the special maps gui.
    GUIOff(MAPS);
    GUIOn(MAINGUI);
    GUIOn(ACTION);
    game.auto_use_walkto_points=0;
    SetMode(DEFAULT);
    SetCharacterClickable(GetPlayerCharacter(),0);
    SetLabelText(ACTION,0,"");
}   

function SetMapRoomLabelPosition(int x, int y) {
  //Sets the position of map-rooms GUI label
   int guiposx, guiposy, height, width, offset;
   string buffer;
   guiposx=x;
   guiposy=y;
   GetLocationName(x,y,buffer);
   width = GetTextWidth(buffer,GUI_MAPS_LABEL_FONT);
   if (width>=GUI_MAPS_WIDTH) offset=GUI_MAPS_WIDTH/2;
   else offset=width/2;
   height=GetTextHeight(buffer,GUI_MAPS_LABEL_FONT,GUI_MAPS_WIDTH);
   if (x>320-offset) guiposx=320-offset;
   if (x<offset) guiposx=offset;
   if (y>200-height) guiposy=200-height;
   SetGUIPosition(MAPS,guiposx-(GUI_MAPS_WIDTH / 2),guiposy);
}
//-----------------------------------------------------

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////// END OF TEMPLATE FUNCTIONS /////////////////////////////////// END OF TEMPLATE FUNCTIONS //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#sectionstart game_start  // DO NOT EDIT OR REMOVE THIS LINE
function game_start() {//////////////////////////////////////////////////////Game Start///////////////////Game Start
     // called when the game starts, before the first room is loaded 
  game.dialog_options_y=1;
  game.dialog_options_x=1;
  game.items_per_line=4;
  game.num_inv_displayed=8;
  game.text_speed=10;
  game.auto_use_walkto_points=0;
  ResetModes();
  GUIOff(MAPS);
  SetDefaultMode(WALK); //edit if you want, but dont delete.
  SetTimer(19,1);//init timer for exits doubleclick
//////////////////////////////////////////////////////////
////////////////////// MODES SETUP ///////////////////////
//////////////////////////////////////////////////////////
//Normal modes:		MODE	"name"	 	AGS	Extension	
//						cursor
//						mode


  DefineMode(		WALK,	"Walk to",	9,	 0 );//The template uses AGS mode 9 for walk modes, instead of 0.
  DefineMode(		LOOK,	"Look at",	1,	'l');
  DefineMode(		TALK,	"Talk to",	3,	't');
  DefineMode(		PICKUP,	"Pick up",	5,	'p');
  DefineMode(		OPEN,	"Open",		8,	'o');
  DefineMode(		CLOSE,	"Close",	8,	'c');
  DefineMode(		PUSH,	"Push",		8,	's');
  DefineMode(		PULL,	"Pull",		8,	'y');
  DefineMode(		SAIL,	"Sail to",	9,	 0 );//you can delete this one, its just for the little demo game.

//Inventory modes:	MODE	"name"	 	Prepo-	Only	Can	Extension
//						sition	inv.	interact
//								w/ inv
  DefineInvMode(	USE,	"Use",		"with",	0,	1,	'u');
  DefineInvMode(	GIVE,	"Give",		"to",	1,	0,	'g');

//*Only inv: 	Means that you can only use that mode followed by an inventory item:
//            	USE has 0, because you can USE a hotspot also. However, you can't
//            	GIVE a hotspot, you must GIVE an inv. item you already have, therefore
//		GIVE has 1.
//*Can interact	USE has 1, because you could have an inventory item like the 
//    with inv:	"navigator's head" in Monkey Island 1, on which if you click 'USE item'
//		then the item performs some action, instead of putting 'USE item WITH'
//		and waiting for the player to select someting to USE the item WITH.
//		An interaction like "GIVE item" on its own, doesn't make sense, 
//		(because you must GIVE something _TO someone_) so GIVE has 0.

// the button sprites probably deppend on the language being used 	
  if (Translation("default")){ // if no translation file is being used
//			mode	button	normal	highlighted
//				number	sprite	sprite
    DefineButton(	GIVE,	0,	13,	22); 
    DefineButton(	PICKUP,	1,	14,	23); 
    DefineButton(	USE,	2,	15,	24);
    DefineButton(	OPEN,	3,	16,	25);
    DefineButton(	LOOK,	4,	17,	26);
    DefineButton(	PUSH,	5,	18,	27);
    DefineButton(	CLOSE,	6,	19,	28);
    DefineButton(	TALK,	7,	20,	29);
    DefineButton(	PULL,	8,	21,	30);
  }
//////////////////////////////////////////////////////////

}
#sectionend game_start  // DO NOT EDIT OR REMOVE THIS LINE

#sectionstart repeatedly_execute  // DO NOT EDIT OR REMOVE THIS LINE
function repeatedly_execute() {//////////////////////////////////////Repeatedly Execute///////////Repeatedly Execute
    // put anything you want to happen every game cycle here
////////PUT YOUR SCRIPTS HERE IF POSSIBLE///////////



////////////////////////////////////////////////////

//	Highlight default action button and
//	change the text in the action bar:
//-----------------------------------------------------
  if (IsGamePaused()!=1 && IsGUIOn(MAPS)==0) {
    HighlightButton(GetDefaultAction(mouse.x,mouse.y));
    UpdateActionBar(mouse.x+GetViewportX(),mouse.y+GetViewportY());
  }
//-----------------------------------------------------

//	Set the label in map rooms:
//-----------------------------------------------------

  if (IsGUIOn(MAPS)){//it moves the gui where the name of what is under the mouse is written in map rooms.
    SetMapRoomLabelPosition(mouse.x,mouse.y);
  }
//-----------------------------------------------------

//	change the arrows in the inventory to 
//	show if you can scroll the inventory:
//-----------------------------------------------------
  if (game.top_inv_item > 0){     //if invent. can scroll up 
    SetButtonPic(MAINGUI,9,1,INV_UP_ARROW_ON_SPRITE);
    if (GetInvAt(FIRST_INV_SLOT_COORDS) < 0)//if no items shown in the inventory
       game.top_inv_item = game.top_inv_item - (game.num_inv_displayed/2 ); //scroll inventory up 
  }
  else //if can not scroll up
    SetButtonPic(MAINGUI,9,1,INV_UP_ARROW_OFF_SPRITE);   
  if (game.top_inv_item < game.num_inv_items - game.num_inv_displayed)   //if invent. can scroll down 
    SetButtonPic(MAINGUI,10,1,INV_DOWN_ARROW_ON_SPRITE);  
  else  // if can not scroll down
    SetButtonPic(MAINGUI,10,1,INV_DOWN_ARROW_OFF_SPRITE);
//-----------------------------------------------------
}
#sectionend repeatedly_execute  // DO NOT EDIT OR REMOVE THIS LINE

#sectionstart on_mouse_click  // DO NOT EDIT OR REMOVE THIS LINE
function on_mouse_click(int button) {////////////////////////////////////On Mouse Click///////////////On Mouse Click
  // called when a mouse button is clicked. button is either LEFT or RIGHT
  
// Store type, name and id# of what the player clicked 
// on in global variables GSloctype,GSlocname & GSlocid:
//-----------------------------------------------------
 int mrx=mouse.x+GetViewportX(), mry=mouse.y+GetViewportY();
 GSloctype=GetLocationType(mouse.x,mouse.y);
 if (GSloctype==1) GSlocid=GetHotspotAt(mouse.x,mouse.y);
 else if (GSloctype==2) GSlocid=GetCharacterAt(mouse.x,mouse.y);
 else if (GSloctype==3) GSlocid=GetObjectAt(mouse.x,mouse.y);
 else if (GetInvAt(mouse.x, mouse.y)>=0) GSlocid=GetInvAt(mouse.x, mouse.y);
 GetLocationName(mouse.x,mouse.y,GSlocname);
//-----------------------------------------------------

 if (IsGamePaused() == 1) {
    // Game is paused, so do nothing (ie. don't allow mouse click)
  }

//	Handling clicks in map rooms:
//-----------------------------------------------------
  else if (IsGUIOn(MAPS)==1){// if map
    if (button==LEFT){
      if (IsInteractionAvailable(mouse.x,mouse.y,MODE_USE)) ProcessClick(mouse.x,mouse.y,MODE_USE);
      else ProcessClick(mouse.x,mouse.y,MODE_WALK);
    }
  }//end if map
//-----------------------------------------------------

//	Handling room clicks:
//-----------------------------------------------------
  else if (button==LEFT || button==RIGHT) {
    
    if (button==RIGHT) SetMode(GetDefaultAction(mouse.x,mouse.y));// set the default mode when right click
    
    if (Extension(GSlocname)==EXITS_EXTENSION){// if its an 'exit'
        HighlightActionBar();
        WalkOffScreen(); 
    }
    else if (ALWAYS_GO_TO_HOTSPOTS==1 && ExtensionEx(2,GSlocname)!='d' && GetLocationType(mouse.x,mouse.y)!=0 ){
       UpdateActionBar(mrx,mry);
       HighlightActionBar();
       if (Go()==1)   ProcessAction(GSmode,mrx,mry);
       return;
    }
    else ProcessAction(GSmode,mrx,mry);
  }
//-----------------------------------------------------

//	Handling inventory clicks:
//-----------------------------------------------------
  else if (button == LEFTINV || button==RIGHTINV){//click in inventory
    if (button == LEFTINV){
      if (GlobalCondition(1)) SetMode(SPECIAL_INV_MODE); //if walk or pickup mode in inventory
    }
    else if (button == RIGHTINV){
      SetMode(GetDefaultAction(mouse.x,mouse.y));
    } 
    ProcessInventoryAction(GSmode,GSlocid);  
  }
//-----------------------------------------------------

}
#sectionend on_mouse_click  // DO NOT EDIT OR REMOVE THIS LINE

#sectionstart on_key_press  // DO NOT EDIT OR REMOVE THIS LINE
function on_key_press(int keycode) {///////////////////////////////////////On Key Press/////////////////On Key Press
  // called when a key is pressed. keycode holds the key's ASCII code

//	Pause/unpause with space bar:
//-----------------------------------------------------
  if (keycode==32){// SPACEBAR
    if (IsGamePaused()==0){
       GUIOn(PAUSED);
       DisableInterface();
    }
    else{
       GUIOff(PAUSED);
       EnableInterface();
    }
  }
//-----------------------------------------------------

//	Confirm exit with 'Y' and 'N' keys:
//-----------------------------------------------------
  if (IsGUIOn(CONFIRMEXIT)==1){ // if exit gui is on 
     if (keycode == CONFIRM_GUIS_CHARACTER_NO) GUIOff(CONFIRMEXIT);//if N is pressed continue
     if (keycode == CONFIRM_GUIS_CHARACTER_YES) QuitGame(0);//if Y is pressed quit game
  }
//-----------------------------------------------------

//	Confirm restart with 'Y' and 'N' keys:
//-----------------------------------------------------
  if (IsGUIOn(RESTART)==1){ // if exit gui is on 
     if (keycode == CONFIRM_GUIS_CHARACTER_NO) GUIOff(RESTART);//if N is pressed continue
     if (keycode == CONFIRM_GUIS_CHARACTER_YES) RestartGame();//if Y is pressed quit game
  }
//-----------------------------------------------------

  if (IsGamePaused() == 1) keycode=0;  // game paused, so don't react to keypresses
  
  if (keycode==359) Display("Adventure Game Studio v2 run-time engine[[Copyright (c) 1999-2004 Chris Jones[[SCUMM template by Proskrito :)");// F1
  if (keycode==363) GUIOn(OPTIONS);   // F5 - OPTIONS
  if (keycode==366) GUIOn(RESTART);  // F8 - RESTART 
  if (keycode==434) SaveScreenShot("scrnshot.bmp");  // F12
  if (keycode==19)  Debug(0,0);  // Ctrl-S, give all inventory
  if (keycode==22)  Debug(1,0);  // Ctrl-V, version
  if (keycode==1)   Debug(2,0);  // Ctrl-A, show walkable areas
  if (keycode==24)  Debug(3,0);  // Ctrl-X, teleport to room

//	Setting cursor modes using keys:
//-----------------------------------------------------
  if (Translation("default")){// if no translation file is being used
    if (keycode == 'G')  SetMode(GIVE);		//G
    if (keycode == 'P')  SetMode(PICKUP);  	//P
    if (keycode == 'U')  SetMode(USE);      	//U
    if (keycode == 'O')  SetMode(OPEN);     	//O
    if (keycode == 'T')  SetMode(TALK);  	//T
    if (keycode == 'S')  SetMode(PUSH);     	//S
    if (keycode == 'C')  SetMode(CLOSE);    	//C
    if (keycode == 'L')  SetMode(LOOK);  	//L
    if (keycode == 'Y')  SetMode(PULL);     	//Y
  }
//-----------------------------------------------------
}
#sectionend on_key_press  // DO NOT EDIT OR REMOVE THIS LINE

#sectionstart interface_click  // DO NOT EDIT OR REMOVE THIS LINE
function interface_click(int interface, int button) {////////////////On Interface Click///////////On Interface Click

  string buffer;
  if (interface == MAINGUI) {

//	Setting cursor modes:
//-----------------------------------------------------
    if (button == 0)  SetMode(GIVE);
    if (button == 1)  SetMode(PICKUP);
    if (button == 2)  SetMode(USE);
    if (button == 3)  SetMode(OPEN);
    if (button == 4)  SetMode(LOOK);
    if (button == 5)  SetMode(PUSH);
    if (button == 6)  SetMode(CLOSE);
    if (button == 7)  SetMode(TALK);
    if (button == 8)  SetMode(PULL);
//-----------------------------------------------------

//	Scrolling the inventory:
//-----------------------------------------------------
    if ((button == 10) && (game.top_inv_item < game.num_inv_items - game.num_inv_displayed))
      game.top_inv_item = game.top_inv_item + (game.num_inv_displayed/2);
    if ((button == 9) && (game.top_inv_item > 0))
      game.top_inv_item = game.top_inv_item - (game.num_inv_displayed/2);
    }
//-----------------------------------------------------

//	Options GUI
//-----------------------------------------------------
 if (interface == OPTIONS) {
    if (button == 0){ //save game
      GUIOff(OPTIONS);
      GetLucasSavegameListBox(SAVE,1); // fills listbox 1 on gui SAVE with saved games
      GUIOn(SAVE);
      }
    if (button == 1){ //load game
      GUIOff(OPTIONS);
      GetLucasSavegameListBox(RESTORE,1);
      GUIOn(RESTORE);
      }
    if (button == 2){ // continue playing
      GUIOff(OPTIONS);
      }
    if (button == 3){ // exit??
      GUIOn(CONFIRMEXIT);
      }
    }
//-----------------------------------------------------

//	Restore game GUI
//-----------------------------------------------------
 if (interface == RESTORE) {
    if (button ==2) GUIOff(RESTORE); //cancel
    if (button ==1){ //click on listbox item
       int index = ListBoxGetSelected(RESTORE,1);
       if (GetSaveSlotDescription(index+100,buffer)==1){ //if there is a savegame here
         GUIOff(RESTORE);
         RestoreGameSlot(index+100); 
        }
       }     
    if (button == 3){ //scroll up
         if (GStopsaveitem<5) GStopsaveitem=0;
         else GStopsaveitem-=5;
      ListBoxSetTopItem(RESTORE,1,GStopsaveitem);
      }
    if (button == 4 && GStopsaveitem<90) //scroll down
      GStopsaveitem+=5;
      ListBoxSetTopItem(RESTORE,1,GStopsaveitem);
    }
//-----------------------------------------------------

//	Save game GUI
//-----------------------------------------------------

 if (interface == SAVE){
    int index=ListBoxGetSelected(SAVE,1);
    if (button == 3){//cancel
      GUIOff(SAVE);
      GUIOff(SAVETEXTBOX);
    }
    if (button == 1){ //click on listbox
     int stbypos;
      StrFormat(buffer,"%d.",index+1);
      SetLabelText(SAVETEXTBOX,1,buffer);
      if (GetSaveSlotDescription(index+100,buffer)==0) StrCopy(buffer,"");//GetSaveSlotDescription(index+100,buffer);
      //else StrCopy(buffer,"");
     SetTextBoxText(SAVETEXTBOX,0,buffer);
     stbypos=28+((index-GStopsaveitem)*(DEFAULT_FONT_HEIGHT+2)); //28 is set by trial-error. Deppends of the savegames listbox position
     if (index<9)  SetGUIObjectPosition(SAVETEXTBOX, 0, 12, 0);
     else SetGUIObjectPosition(SAVETEXTBOX, 0, 18, 0);     
     SetGUIPosition(SAVETEXTBOX,29,stbypos);// 29 is set by trial-error. Same as above.
     GUIOn(SAVETEXTBOX);
    }
    if (button == 2 && index>=0) { //save
      GetTextBoxText(SAVETEXTBOX,0,buffer);
      GUIOff(SAVE);
      GUIOff(SAVETEXTBOX);
      SaveGameSlot(index+100,buffer);
    } 
    if (button == 4){// scroll up
       GUIOff(SAVETEXTBOX);
       ListBoxSetSelected(SAVE,1,-1);
         if (GStopsaveitem<5) GStopsaveitem=0;
         else GStopsaveitem-=5;
       ListBoxSetTopItem(SAVE,1,GStopsaveitem);
    }
    if (button == 5 && GStopsaveitem<90){ //scroll down
       GUIOff(SAVETEXTBOX);
       ListBoxSetSelected(SAVE,1,-1);
       GStopsaveitem+=5;
       ListBoxSetTopItem(SAVE,1,GStopsaveitem);
    }
  }
 if (interface == SAVETEXTBOX){
    int index=ListBoxGetSelected(SAVE,1);
    if (button == 0){
      GetTextBoxText(SAVETEXTBOX,0,buffer);
      GUIOff(SAVE);
      GUIOff(SAVETEXTBOX);
      SaveGameSlot(index+100,buffer);
    }
    if (IsButtonDown(RIGHT)) GUIOff(SAVETEXTBOX);  
 }
//-----------------------------------------------------

}
#sectionend interface_click  // DO NOT EDIT OR REMOVE THIS LINE


#sectionstart on_event  // DO NOT EDIT OR REMOVE THIS LINE
function on_event (int event, int data) {//////////////////////////////////////On Event/////////////////////On Event
  if (event == ENTER_ROOM) MoveToWalkableArea(GetPlayerCharacter());
}
#sectionend on_event  // DO NOT EDIT OR REMOVE THIS LINE

#sectionstart dialog_request  // DO NOT EDIT OR REMOVE THIS LINE
function dialog_request (int parameter) {////////////////////////////////Dialog request///////////////Dialog request

}
#sectionend dialog_request  // DO NOT EDIT OR REMOVE THIS LINE


function unhandled_event(int xxx, int yyy){/////////////////////////////Unhandled Event//////////////Unhandled Event
  int type=GSloctype;
  string locationname,usedinvname;
  StrCopy(locationname,GSlocname);
  RemoveExtension(locationname);
  if (GetInvAt(mouse.x,mouse.y)>=0) type=4;
  if (Tmode[GSusedmode].AGSmode==4){
     GetInvName(character[GetPlayerCharacter()].activeinv ,usedinvname);
     RemoveExtension(usedinvname);
    if (type>0) type+=4;
  }
  if (Tmode[GSusedmode].AGSmode==9 && (ALWAYS_GO_TO_HOTSPOTS==0 || ExtensionEx(2,GSlocname)=='d') )
  ProcessClick(mouse.x,mouse.y,MODE_WALK);
  else if (Tmode[GSusedmode].AGSmode!=9 && type!=0 && IsGUIOn(MAPS)==0){

 //Check modes with: if(UsedMode(MODE)), check types with: if(type==#). types:
 // 1   a hotspot
 // 2   a character
 // 3   an object
 // 4   an inventory item.
 // 5   inv. item on hotspot
 // 6   inv. item on character
 // 7   inv. item on object
 // 8   inv. item on inv. item
 //
 // You have the string "locationname" that is the name of
 // what you clicked on, and the string "usedinvname" that is
 // the name of the item that was used on where you clicked (only for types 5,6,7,8)
 /////////////////////////////////////////////////////////////////

// REPLACE THESE SAMPLE INTERACTIONS WITH YOURS:

    if (UsedMode(USE)){
      if (type>=5) Display("That won't do any good");// if tried to use an inventory item with something
      else Display("I can't use that"); // if tried to use something else (like a hotspot or object)
    }
    else if (UsedMode(LOOK)){
      if (type!=2) Display("Nice %s", locationname);//if its not a character
      else Display("It's %s",locationname);      
    }
    else if (UsedMode(TALK)){
      if (type==2) Display("I don't want to talk to %s", locationname); //if its a character
      else Display("It doesn't talk");
    }
    else if (UsedMode(GIVE)) Display("I'd rather keep it");
    else if (UsedMode(PICKUP)) Display("I can't pick that up");
    else if (UsedMode(OPEN)) Display("I can't open that");
    else if (UsedMode(CLOSE)) Display("I can't close that");
    else if (UsedMode(PUSH)) Display("I can't push that");
    else if (UsedMode(PULL)) Display("I can't pull that");


////////////////////////////////////////////////////
  }
}
  
function Unhandled(){
  unhandled_event(0,0);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////// INTERACTION FUNCTIONS ///////////////////////////////////////// INTERACTION FUNCTIONS //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#sectionstart inventory1_a  // DO NOT EDIT OR REMOVE THIS LINE
function inventory1_a() {
  // script for inventory1: Other click on inventory item
if (UsedMode(OPEN)) Display("Abriendo");  
else Unhandled();
}
#sectionend inventory1_a  // DO NOT EDIT OR REMOVE THIS LINE


#sectionstart inventory1_b  // DO NOT EDIT OR REMOVE THIS LINE
function inventory1_b() {
  // script for inventory1: Look at inventory item
Display("mirando");  
}
#sectionend inventory1_b  // DO NOT EDIT OR REMOVE THIS LINE


#sectionstart inventory2_a  // DO NOT EDIT OR REMOVE THIS LINE
function inventory2_a() {
  // script for inventory2: Other click on inventory item
if (UsedMode(PUSH)) Display("empujando");  
else Unhandled();
}
#sectionend inventory2_a  // DO NOT EDIT OR REMOVE THIS LINE



#sectionstart inventory3_a  // DO NOT EDIT OR REMOVE THIS LINE
function inventory3_a() {
  // script for inventory3: Other click on inventory item
  
if (UsedMode(PUSH)) Display("empujando");  
else Unhandled();
}
#sectionend inventory3_a  // DO NOT EDIT OR REMOVE THIS LINE


#sectionstart inventory2_b  // DO NOT EDIT OR REMOVE THIS LINE
function inventory2_b() {
  // script for inventory2: Interact inventory item
if (UsedMode(USE)) Display("Usandoo");  
}
#sectionend inventory2_b  // DO NOT EDIT OR REMOVE THIS LINE


#sectionstart inventory3_b  // DO NOT EDIT OR REMOVE THIS LINE
function inventory3_b() {
  // script for inventory3: Use inventory on this item
Display("not in this crappy game");  
}
#sectionend inventory3_b  // DO NOT EDIT OR REMOVE THIS LINE


#sectionstart inventory1_c  // DO NOT EDIT OR REMOVE THIS LINE
function inventory1_c() {
  // script for inventory1: Use inventory on this item
    if (UsedInvMode(USE,3)){
// Display ("Chachipiruli");  
LoseInventory(1);
LoseInventory(3);
AddInventory(2);
}

}
#sectionend inventory1_c  // DO NOT EDIT OR REMOVE THIS LINE

function iInventory3_UseInv()
{
if (player.ActiveInventory == inventory[1]) {
inventory3_b();
}
else {
 unhandled_event(5, 3);
}
}
